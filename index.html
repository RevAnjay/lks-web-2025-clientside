<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="main-menu">
        <div>
            <div>
                <img src="Images/logo.png" alt="">
            </div>
            <h1 class="title-menu">MAIN<span class="boom"> </span>MENU</h1>

            <input type="text" placeholder="Input Username" id="username">
            <select name="level" id="level">
                <option disabled selected>Select Level</option>
                <option value="easy">Easy</option>
                <option value="medium">Medium</option>
                <option value="hard">Hard</option>
            </select>
            <div>
                <button id="play">Play</button>
                <button id="open-instruction">Instruction</button>
            </div>
        </div>
    </div>
    <div class="instruction">
        <div class="instruction-text">
            <button class="close-instruction" id="close-button-instruction">X</button>
            <h1>How to play game</h1>
            <p>1. Input Username</p>
        </div>
    </div>
    <div class="pause-game">
        <div class="pause-text">
            <button class="close-pause" id="close-button-pause">X</button>
            <h1>Pause Menu</h1>
            <p>Apakah kamu ingin melanjutkan game atau tidak?</p>
            <button class="pause-button" id="stop-game">Keluar</button>
            <button class="pause-button" id="continue-game">Lanjut</button>
        </div>
    </div>
    <div class="game-over" id="game-over">
        <div class="box">
            <h1>Game Over</h1>
            <p id="final-score">Kamu kalah!</p>
            <div>
                <button id="go-restart">Restart</button>
                <button id="go-main">Main Menu</button>
            </div>
        </div>
    </div>
    <div class="game">
        <h1 class="title-game">Games</h1>
        <canvas id="canvas" width="1000" height="600"></canvas>
    </div>
</body>
<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext("2d");
    const gameOverEl = document.getElementById('game-over');
    const goRestart = document.getElementById('go-restart');
    const goMain = document.getElementById('go-main');
    const closeButtonInstruction = document.getElementById('close-button-instruction');
    const closeButtonPause = document.getElementById('close-button-pause');
    const openButton = document.getElementById('open-instruction');
    const mainMenu = document.querySelector(".main-menu");
    const instructionMenu = document.querySelector(".instruction");
    const pauseMenu = document.querySelector(".pause-game");
    const playButton = document.getElementById("play");
    const gameMenu = document.querySelector(".game");
    const usernameInput = document.getElementById("username");
    const levelSection = document.getElementById("level");
    const buttonStopGame = document.getElementById("stop-game");
    const buttonContinueGame = document.getElementById("continue-game");
    const grid = 64;
    const numRows = 9;
    const numCols = 11;
    const mainMap = [   
        [1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,2,0,2,0,0,0,1],
        [1,0,1,0,1,0,1,2,1,2,1],
        [1,0,0,0,2,0,0,0,0,0,1],
        [1,2,1,0,1,0,1,2,1,0,1],
        [1,0,2,0,2,0,2,0,0,2,1],
        [1,0,1,0,1,0,1,0,1,0,1],
        [1,0,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1]
    ];
    let map = mainMap;
    let gameTime = 120;
    let timer = 0;
    let isPaused = null;    
    let brick = 0;
    let bombs = []

    //image
    const playerDImage = new Image();
    playerDImage.src = "Images/char_down.png"

    const playerLImage = new Image();
    playerLImage.src = "Images/char_left.png"

    const playerRImage = new Image();
    playerRImage.src = "Images/char_right.png"

    const playerUImage = new Image();
    playerUImage.src = "Images/char_up.png"

    const bgImage = new Image();
    bgImage.src = "Images/background.jpg"

    const softWall = new Image();
    softWall.src = "Images/wall.png"

    const crackWall = new Image();
    crackWall.src = "Images/wall_crack.png"

    const dogUImage = new Image();
    dogUImage.src = "Images/dog_up.png"

    const dogDImage = new Image();
    dogDImage.src = "Images/dog_down.png"

    const dogLImage = new Image();
    dogLImage.src = "Images/dog_left.png"

    const dogRImage = new Image();
    dogRImage.src = "Images/dog_right.png"

    const bombImage = new Image();
    bombImage.src = "Images/bomb.png"

    const explosionImage = new Image();
    explosionImage.src = "Images/explosion.png"
    //player
    const player = {
        row: 1,
        col: 1,
        numBombs: 1,
        bombSize: 3,
        radius: grid * 0.35,
        currentImage: playerDImage,
        health: 3,
        render() {

            // Gambar karakter
            if (this.currentImage.complete) {
                ctx.drawImage(this.currentImage, this.col * grid, this.row * grid, grid, grid);
            }
        }
    }

    const tileSize = 65;

    const randomMap =  {
        map1: [
            [1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,2,0,2,0,0,4,1],
            [1,0,1,0,1,0,1,2,1,2,1],
            [1,0,0,0,2,0,0,0,0,0,1],
            [1,2,1,0,1,0,1,2,1,0,1],
            [1,0,2,0,2,0,2,0,0,2,1],
            [1,0,1,0,1,0,1,0,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1]
        ],
        
        map2: [
            [1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,2,2,0,2,2,2,0,1],
            [1,0,1,0,1,0,1,2,1,2,1],
            [1,0,0,0,2,2,2,0,0,0,1],
            [1,2,1,2,1,2,1,2,1,0,1],
            [1,0,2,2,2,2,2,0,0,2,1],
            [1,2,1,2,1,2,1,2,1,2,1],
            [1,2,2,2,2,0,0,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1]
        ],

        map3: [
            [1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,2,2,2,2,2,2,1],
            [1,0,1,2,1,2,1,2,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,2,1,2,1,2,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,2,1,2,1,2,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1]
        ],
    }

    const types = {
        wall: 1,
        softWall: 2,
        bomb: 3
    };

    let cells = []
    let dogs = [];

    function spawnDogs() {
        dogs = [];
        for (let r = 0; r < numRows; r++) {
            for (let c = 0; c < numCols; c++) {
                if (map[r][c] === 4) {
                    dogs.push({ row: r, col: c, dir: 'left', moveTimer: 0, moveInterval: 400 });
                    // clear map cell so it's not treated as obstacle in drawing
                    map[r][c] = 0;
                }
            }
        }
    }

    // simple BFS to find next step from (sr,sc) to (tr,tc)
    function findNextStep(sr, sc, tr, tc) {
        const q = [];
        const visited = Array.from({ length: numRows }, () => Array(numCols).fill(false));
        const prev = Array.from({ length: numRows }, () => Array(numCols).fill(null));
        q.push([sr, sc]);
        visited[sr][sc] = true;
        const dirs = [ [-1,0],[1,0],[0,-1],[0,1] ];

        while (q.length) {
            const [r,c] = q.shift();
            if (r === tr && c === tc) break;
            for (let [dr,dc] of dirs) {
                const nr = r + dr, nc = c + dc;
                if (nr < 0 || nr >= numRows || nc < 0 || nc >= numCols) continue;
                if (visited[nr][nc]) continue;
                // blocked if wall (1) or soft wall (2)
                if (map[nr][nc] === 1 || map[nr][nc] === 2) continue;
                visited[nr][nc] = true;
                prev[nr][nc] = [r,c];
                q.push([nr,nc]);
            }
        }

        if (!visited[tr] || !visited[tr][tc]) return null;
        // reconstruct path
        let cur = [tr, tc];
        const path = [];
        while (cur && !(cur[0] === sr && cur[1] === sc)) {
            path.push(cur);
            cur = prev[cur[0]][cur[1]];
        }
        if (path.length === 0) return null;
        const next = path[path.length - 1];
        return next; // [r,c]
    }

    function updateDogs(delta) {
        if (!Array.isArray(dogs)) return;
        for (let d of dogs) {
            d.moveTimer -= delta;
            if (d.moveTimer > 0) continue;
            d.moveTimer = d.moveInterval;
            // find next step towards player
            const next = findNextStep(d.row, d.col, player.row, player.col);
            if (next) {
                const [nr, nc] = next;
                // determine direction
                if (nr < d.row) d.dir = 'up';
                else if (nr > d.row) d.dir = 'down';
                else if (nc < d.col) d.dir = 'left';
                else if (nc > d.col) d.dir = 'right';

                d.row = nr; d.col = nc;
                // if dog steps on player -> damage
                if (d.row === player.row && d.col === player.col) {
                    player.health = Math.max(0, player.health - 1);
                    if (player.health <= 0) showGameOver();
                }
            } else {
                // no path: optionally wander randomly a step
                const choices = [[-1,0],[1,0],[0,-1],[0,1]];
                for (let [dr,dc] of choices) {
                    const nr = d.row + dr, nc = d.col + dc;
                    if (nr < 0 || nr >= numRows || nc < 0 || nc >= numCols) continue;
                    if (map[nr][nc] === 0 && Math.random() < 0.25) {
                        d.row = nr; d.col = nc; break;
                    }
                }
            }
        }
    }

    function generateLevel() {
        cells = [];

        for (let i = 0; i < numRows; i++) {
            cells[i] = [];

            for (let col = 0; col < numCols; col++) {
                cells[i][col] = map[i][col];

                if (map[i][col] === 0 && Math.random() < 0.90) {
                    cells[i][col] = types.softWall;
                }
            }
        }
    }

    function drawMap() {
        // Draw HANYA soft wall (nilai 2) dari map original
        for (let row = 0; row < numRows; row++) {
            for (let col = 0; col < numCols; col++) {
                const x = col * grid;
                const y = row * grid;

                // Hanya draw jika map[row][col] === 2 (soft wall)
                if (map[row][col] === 2) {
                    if (softWall.complete) {
                        ctx.drawImage(softWall, x, y, grid, grid);
                    }
                }
            }
        }
    }

    function drawDog() {
        // draw dogs from `dogs` array (spawned at level load)
        if (!Array.isArray(dogs)) return;
        for (let d of dogs) {
            const x = d.col * grid;
            const y = d.row * grid;
            let img = dogLImage;
            if (d.dir === 'up') img = dogUImage;
            else if (d.dir === 'down') img = dogDImage;
            else if (d.dir === 'left') img = dogLImage;
            else if (d.dir === 'right') img = dogRImage;

            if (img && img.complete) ctx.drawImage(img, x, y, grid, grid);
        }
    }

    function drawBomb() {
        for (let bomb of bombs) {
            let x = bomb.col * grid;
            let y = bomb.row * grid;
            // Jika bom sudah meledak, kita gunakan efek CSS DOM, tidak menggambar ledakan di canvas
            if (bomb.exploded) {
                // skip canvas explosion drawing
                continue;
            } else {
                try {
                    if (bombImage.complete) {
                        ctx.drawImage(bombImage, x, y, grid, grid);
                    }
                } catch (err) {
                    console.warn('draw bomb failed', err);
                }
            }

        }
    }

    function updateBomb() {
        for (let i = bombs.length - 1; i >= 0; i--) {
            bombs[i].timer -= 16;
            console.log(bombs[i].timer);

            // Jika timer selesai dan bom belum meledak -> meledakkan
            if (bombs[i].timer <= 0 && !bombs[i].exploded) {
                explodeBomb(bombs[i]);
                continue;
            }

            // Jika sudah meledak, hitung explosionTimer untuk menghapus efek
            if (bombs[i].exploded) {
                bombs[i].explosionTimer -= 16;
                if (bombs[i].explosionTimer <= 0) {
                    // hapus DOM explosion jika ada
                    if (bombs[i].domExplosions && Array.isArray(bombs[i].domExplosions)) {
                        for (let el of bombs[i].domExplosions) {
                            if (el && el.parentNode) el.parentNode.removeChild(el);
                        }
                    }
                    bombs.splice(i, 1);
                }
            }
        }
    }

    function calcHealth() {
        if (player.health == 3) {
            return "❤❤❤";
        } else if (player.health == 2) {
            return "❤❤";
        } else if (player.health == 1) {
            return "❤";
        } else {
            return "Game Over";
        }
    }

    function calcWallCount() {
        for (let row = 0; row < numRows; row++) {
            for (let col = 0; col < numCols; col++) {
                const x = col * grid;
                const y = row * grid;

                // Hanya draw jika map[row][col] === 2 (soft wall)
                if (map[row][col] === 2) {
                    if (softWall.complete) {
                        brick++;
                    }
                }
            }
        }
    }
    

    function startTimer() {
        gameTime = 120;

        setInterval(() => {
            if (!isPaused) {
                timer++
            }

            if (timer >= gameTime) {
                clearInterval();
                console.log(timer)
                location.reload();
            }
        }, 1000)
    }

    function bomb(row, col, size, owner) {
        this.row = row
        this.col = col
        this.size = size
        this.owner = owner

        this.bombTimer = 3000

        
    }


    function gameLoad() {
        // Panel kanan
        ctx.fillStyle = "#333";  
        ctx.fillRect(700, 0, 400, canvas.height);

        // Tulis teks status
        ctx.font = "20px Arial";
        ctx.fillStyle = "white";
        ctx.textAlign = "left";
        ctx.fillText("Player : " + usernameInput.value, 700, 100);
        ctx.fillText("Time   : " + timer, 700, 130);
        ctx.fillText(calcHealth(), 700, 180);
        ctx.fillText("Brick = " + brick, 700, 220);
        ctx.fillText("Bomb  = 0", 700, 250);
        ctx.fillText("Ice   = 1", 700, 280);
        
        // Hapus generateLevel() - gunakan map original
        startTimer();
        spawnDogs();
        gameLoop();
        calcWallCount();
    }

    function showGameOver() {
        isPaused = true;
        if (gameOverEl) {
            const finalScore = document.getElementById('final-score');
            if (finalScore) finalScore.textContent = 'Hati habis!';
            gameOverEl.classList.add('show');
        }
    }

    if (goRestart) {
        goRestart.addEventListener('click', () => {
            location.reload();
        });
    }

    if (goMain) {
        goMain.addEventListener('click', () => {
            // kembali ke main menu
            gameOverEl.classList.remove('show');
            mainMenu.classList.remove('hide');
            gameMenu.classList.remove('playing');
            isPaused = null;
            // reset state sederhana dengan reload untuk keamanan
            location.reload();
        });
    }

    
    openButton.addEventListener("click", () => {
        instructionMenu.classList.add("show")
    })

    closeButtonInstruction.addEventListener("click", () => {
        instructionMenu.classList.remove("show");
    })

    closeButtonPause.addEventListener("click", () => {
        isPaused = false;
        pauseMenu.classList.remove("show");
    })

    buttonStopGame.addEventListener("click", () => {
        location.reload();
    })

    buttonContinueGame.addEventListener("click", () => {
        isPaused = false;
        pauseMenu.classList.remove("show");
    })

    playButton.addEventListener("click", () => {
        if (usernameInput.value < 4) {
            alert("tolong masukan username");
            return;
        }// else if (usernameInput.length <= 4) {
        //     alert("username minimal 4 huruf");
        //     return;
        // }
        
        switch(levelSection.value) {
            case ("easy"):
                map = randomMap.map1
                instructionMenu.classList.remove("show");
                mainMenu.classList.add("hide");
                gameMenu.classList.add("playing");
                gameLoad()
                return;
            case ("medium"):
                map = randomMap.map2
                instructionMenu.classList.remove("show");
                mainMenu.classList.add("hide");
                gameMenu.classList.add("playing");
                gameLoad()
                return;
            case ("hard"):
                map = randomMap.map3
                instructionMenu.classList.remove("show");
                mainMenu.classList.add("hide");
                gameMenu.classList.add("playing");
                gameLoad()
                return;
            default:
                alert("level belum tersedia");
                return;
        }
    })



    

    // function movePlayer(e) {
    //     let col = player.col
    //     let row = player.row
        
    //     if (e.key == "w") {
    //         removePlayer(player.x, player.y)
    //         player.y--
    //         drawEntities(playerUImage, player.x, player.y)
    //     }else if (e.key == "a") {
    //         removePlayer(player.x, player.y)
    //         player.x--
    //         drawEntities(playerLImage, player.x, player.y)
    //     }else if (e.key == "s") {
    //         removePlayer(player.x, player.y)
    //         player.y++
    //         drawEntities(playerDImage, player.x, player.y)
    //     }else if (e.key == "d") {
    //         removePlayer(player.x, player.y)
    //         player.x++
    //         drawEntities(playerRImage, player.x, player.y)
    //     }
    // }
    function movePlayer(e) {
        let col = player.col
        let row = player.row
        
        if (e.key == "w" || e.key == "ArrowUp") {
            row--
            player.currentImage = playerUImage;
        }else if (e.key == "a" || e.key == "ArrowLeft") {
            col--
            player.currentImage = playerLImage;
        }else if (e.key == "s" || e.key == "ArrowDown") {
            row++
            player.currentImage = playerDImage;
        }else if (e.key == "d" || e.key == "ArrowRight") {
            col++
            player.currentImage = playerRImage;
        }

        if (map[row] && map[row][col] === 0) {
            player.row = row;
            player.col = col;
        }
    }

    function playerBomb(e) {
        let col = player.col;
        let row = player.row;

        if (e.key == "Space" || e.key == " ") {
            console.log("space!!")

            if (map[row][col] !== 0) {
                return;
            }

            let existsBomb = bombs.some(b => b.col == col && b.row == row)
            if (existsBomb) return;

            bombs.push({
                col: col,
                row: row,
                timer: 3000,
                size: player.bombSize || 1,
                exploded: false,
                explosions: null,
                explosionTimer: 0
            });
        }
    }

    function explodeBomb(bomb) {
        bomb.exploded = true;
        // waktu tampil ledakan (ms)
        bomb.explosionTimer = 600;
        bomb.explosions = [];

        // Pastikan size minimal 1
        const size = Math.max(1, bomb.size || 1);

        // Masukkan tile pusat
        bomb.explosions.push({ row: bomb.row, col: bomb.col });

        const directions = [ {r:-1,c:0}, {r:1,c:0}, {r:0,c:-1}, {r:0,c:1} ];

        // Untuk setiap arah, tambahkan sampai ukuran (size-1) atau sampai bertemu wall tipe 1
        for (let d of directions) {
            for (let step = 1; step < size; step++) {
                const r = bomb.row + d.r * step;
                const c = bomb.col + d.c * step;

                if (!map[r] || typeof map[r][c] === 'undefined') break;

                // berhenti jika wall kuat (1) — tidak menimpa dan tidak menambah efek di belakangnya
                if (map[r][c] === 1) break;

                // tambahkan tile terpengaruh (efek ledakan ditampilkan), tapi hanya tipe 2 yang diubah
                bomb.explosions.push({ row: r, col: c });

                if (map[r][c] === 2) {
                    // hancurkan soft wall
                    map[r][c] = 0;
                    if (brick > 0) brick--;
                    // hentikan propagasi setelah menghancurkan soft wall
                    break;
                }
                // jika kosong (0) teruskan sampai mencapai size
            }
        }

        // Efek ke pemain: hanya mengurangi health jika posisi pemain berada di salah satu tile ledakan
        let playerHit = false;
        for (let cell of bomb.explosions) {
            if (player.row === cell.row && player.col === cell.col) {
                player.health = Math.max(0, player.health - 1);
                playerHit = true;
            }
        }

        // Jika nyawa habis, tampilkan Game Over
        if (player.health <= 0) {
            showGameOver();
        }

        // Buat elemen DOM explosion untuk setiap tile (CSS-based effect)
        bomb.domExplosions = [];
        const container = document.querySelector('.game');
        if (container) {
            // compute canvas offset inside container to align explosions exactly on canvas grid
            const canvasRect = canvas.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            const offsetLeft = canvasRect.left - containerRect.left;
            const offsetTop = canvasRect.top - containerRect.top;

            for (let cell of bomb.explosions) {
                const el = document.createElement('div');
                el.className = 'explosion';
                // position relative to the canvas inside .game
                el.style.left = (offsetLeft + cell.col * grid) + 'px';
                el.style.top = (offsetTop + cell.row * grid) + 'px';
                el.style.width = grid + 'px';
                el.style.height = grid + 'px';

                // add arms to visually create a '+' shape
                for (let a = 0; a < 4; a++) {
                    const arm = document.createElement('div');
                    arm.className = 'explosion arm';
                    arm.style.position = 'absolute';
                    arm.style.pointerEvents = 'none';
                    arm.style.background = 'transparent';
                    if (a === 0) { // up
                        arm.style.width = (grid * 0.25) + 'px';
                        arm.style.height = (grid * 0.6) + 'px';
                        arm.style.left = (grid * 0.375) + 'px';
                        arm.style.top = '-' + (grid * 0.6) + 'px';
                    } else if (a === 1) { // down
                        arm.style.width = (grid * 0.25) + 'px';
                        arm.style.height = (grid * 0.6) + 'px';
                        arm.style.left = (grid * 0.375) + 'px';
                        arm.style.top = (grid) + 'px';
                    } else if (a === 2) { // left
                        arm.style.width = (grid * 0.6) + 'px';
                        arm.style.height = (grid * 0.25) + 'px';
                        arm.style.left = '-' + (grid * 0.6) + 'px';
                        arm.style.top = (grid * 0.375) + 'px';
                    } else { // right
                        arm.style.width = (grid * 0.6) + 'px';
                        arm.style.height = (grid * 0.25) + 'px';
                        arm.style.left = (grid) + 'px';
                        arm.style.top = (grid * 0.375) + 'px';
                    }
                    el.appendChild(arm);
                }
                container.appendChild(el);
                bomb.domExplosions.push(el);
            }
        }
    }

    function removePlayer(positionX, positionY) {
        let tile = map[positionX, positionY];

        // if (tile === 0) {

        // } else if () {

        // }
        //ctx.clearRect(positionX*tileSize, positionY*tileSize, tileSize, tileSize)
    }

    function drawEntities(image, positionX, positionY) {
        if (image.complete) {
            const x = positionX * grid;
            const y = positionY * grid;
            ctx.drawImage(image, x, y, grid, grid);
        }
    }

    function gameLoop () {
        ctx.clearRect(0, 0, 1000, 600);
        
        if (bgImage.complete) {
            ctx.drawImage(bgImage, 0, 0, 704, 576);
        }

        drawMap();
        drawDog();
        drawBomb();
        updateBomb();

        // Update dogs with approximate frame delta (16ms per frame)
        updateDogs(16);

        player.render();

        ctx.fillStyle = "#333";  
        ctx.fillRect(700, 0, 400, canvas.height);
        
        ctx.font = "20px Arial";
        ctx.fillStyle = "white";
        ctx.textAlign = "left";
        ctx.fillText("Player : " + usernameInput.value, 720, 100);
        ctx.fillText("Time   : " + timer, 720, 130);
        ctx.fillText(calcHealth(), 720, 180);
        ctx.fillText("Brick = " + brick, 720, 220);
        ctx.fillText("Bomb  = 0", 720, 250);
        ctx.fillText("Ice   = 1", 720, 280);
        
        requestAnimationFrame(gameLoop);
    }

    document.addEventListener("keydown", (e) => {
        movePlayer(e)
        playerBomb(e)

        if (e.key == "Escape" && isPaused) {
            isPaused = false;
            pauseMenu.classList.remove("show");
        } else if(e.key == "Escape") {
            isPaused = true;
            pauseMenu.classList.add("show")
        }
        
    })
    

    // document.addEventListener("keydown", (e) => {
    //     if (e.key == "d") {
    //         player.x++
    //         console.log("aaaaa")
    //     }
    // })
</script>
</html>